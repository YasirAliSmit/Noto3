/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


template <typename T>
class JSI_EXPORT NativeAppModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "RNAppModule";

protected:
  NativeAppModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeAppModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["initializeApp"] = MethodMetadata {.argCount = 2, .invoker = __initializeApp};
    methodMap_["setAutomaticDataCollectionEnabled"] = MethodMetadata {.argCount = 2, .invoker = __setAutomaticDataCollectionEnabled};
    methodMap_["deleteApp"] = MethodMetadata {.argCount = 1, .invoker = __deleteApp};
    methodMap_["eventsNotifyReady"] = MethodMetadata {.argCount = 1, .invoker = __eventsNotifyReady};
    methodMap_["eventsGetListeners"] = MethodMetadata {.argCount = 0, .invoker = __eventsGetListeners};
    methodMap_["eventsPing"] = MethodMetadata {.argCount = 2, .invoker = __eventsPing};
    methodMap_["eventsAddListener"] = MethodMetadata {.argCount = 1, .invoker = __eventsAddListener};
    methodMap_["eventsRemoveListener"] = MethodMetadata {.argCount = 2, .invoker = __eventsRemoveListener};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
    methodMap_["metaGetAll"] = MethodMetadata {.argCount = 0, .invoker = __metaGetAll};
    methodMap_["jsonGetAll"] = MethodMetadata {.argCount = 0, .invoker = __jsonGetAll};
    methodMap_["preferencesSetBool"] = MethodMetadata {.argCount = 2, .invoker = __preferencesSetBool};
    methodMap_["preferencesSetString"] = MethodMetadata {.argCount = 2, .invoker = __preferencesSetString};
    methodMap_["preferencesGetAll"] = MethodMetadata {.argCount = 0, .invoker = __preferencesGetAll};
    methodMap_["preferencesClearAll"] = MethodMetadata {.argCount = 0, .invoker = __preferencesClearAll};
  }
  
private:
  static jsi::Value __initializeApp(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::initializeApp) == 3,
      "Expected initializeApp(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::initializeApp,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));
  }

  static jsi::Value __setAutomaticDataCollectionEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setAutomaticDataCollectionEnabled) == 3,
      "Expected setAutomaticDataCollectionEnabled(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::setAutomaticDataCollectionEnabled,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __deleteApp(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::deleteApp) == 2,
      "Expected deleteApp(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::deleteApp,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __eventsNotifyReady(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::eventsNotifyReady) == 2,
      "Expected eventsNotifyReady(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::eventsNotifyReady,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __eventsGetListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::eventsGetListeners) == 1,
      "Expected eventsGetListeners(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::eventsGetListeners,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __eventsPing(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::eventsPing) == 3,
      "Expected eventsPing(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::eventsPing,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));
  }

  static jsi::Value __eventsAddListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::eventsAddListener) == 2,
      "Expected eventsAddListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::eventsAddListener,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __eventsRemoveListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::eventsRemoveListener) == 3,
      "Expected eventsRemoveListener(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::eventsRemoveListener,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool());return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __metaGetAll(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::metaGetAll) == 1,
      "Expected metaGetAll(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::metaGetAll,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __jsonGetAll(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::jsonGetAll) == 1,
      "Expected jsonGetAll(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::jsonGetAll,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __preferencesSetBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::preferencesSetBool) == 3,
      "Expected preferencesSetBool(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::preferencesSetBool,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool());
  }

  static jsi::Value __preferencesSetString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::preferencesSetString) == 3,
      "Expected preferencesSetString(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::preferencesSetString,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt));
  }

  static jsi::Value __preferencesGetAll(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::preferencesGetAll) == 1,
      "Expected preferencesGetAll(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::preferencesGetAll,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __preferencesClearAll(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::preferencesClearAll) == 1,
      "Expected preferencesClearAll(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::preferencesClearAll,  static_cast<NativeAppModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }
};


template <typename T>
class JSI_EXPORT NativeAppOpenModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "RNGoogleMobileAdsAppOpenModule";

protected:
  NativeAppOpenModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeAppOpenModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["appOpenLoad"] = MethodMetadata {.argCount = 3, .invoker = __appOpenLoad};
    methodMap_["appOpenShow"] = MethodMetadata {.argCount = 3, .invoker = __appOpenShow};
  }
  
private:
  static jsi::Value __appOpenLoad(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::appOpenLoad) == 4,
      "Expected appOpenLoad(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::appOpenLoad,  static_cast<NativeAppOpenModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __appOpenShow(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::appOpenShow) == 4,
      "Expected appOpenShow(...) to have 4 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::appOpenShow,  static_cast<NativeAppOpenModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asObject(rt)));
  }
};


#pragma mark - NativeConsentModuleAdsConsentDebugGeography

enum class NativeConsentModuleAdsConsentDebugGeography { DISABLED, EEA, NOT_EEA, REGULATED_US_STATE, OTHER };

template <>
struct Bridging<NativeConsentModuleAdsConsentDebugGeography> {
  static NativeConsentModuleAdsConsentDebugGeography fromJs(jsi::Runtime &rt, const jsi::Value &rawValue) {
    double value = (double)rawValue.asNumber();
    if (value == 0) {
      return NativeConsentModuleAdsConsentDebugGeography::DISABLED;
    } else if (value == 1) {
      return NativeConsentModuleAdsConsentDebugGeography::EEA;
    } else if (value == 2) {
      return NativeConsentModuleAdsConsentDebugGeography::NOT_EEA;
    } else if (value == 3) {
      return NativeConsentModuleAdsConsentDebugGeography::REGULATED_US_STATE;
    } else if (value == 4) {
      return NativeConsentModuleAdsConsentDebugGeography::OTHER;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value in NativeConsentModuleAdsConsentDebugGeography");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, NativeConsentModuleAdsConsentDebugGeography value) {
    if (value == NativeConsentModuleAdsConsentDebugGeography::DISABLED) {
      return bridging::toJs(rt, 0);
    } else if (value == NativeConsentModuleAdsConsentDebugGeography::EEA) {
      return bridging::toJs(rt, 1);
    } else if (value == NativeConsentModuleAdsConsentDebugGeography::NOT_EEA) {
      return bridging::toJs(rt, 2);
    } else if (value == NativeConsentModuleAdsConsentDebugGeography::REGULATED_US_STATE) {
      return bridging::toJs(rt, 3);
    } else if (value == NativeConsentModuleAdsConsentDebugGeography::OTHER) {
      return bridging::toJs(rt, 4);
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value in NativeConsentModuleAdsConsentDebugGeography");
    }
  }
};

#pragma mark - NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus

enum class NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus { UNKNOWN, REQUIRED, NOT_REQUIRED };

template <>
struct Bridging<NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus> {
  static NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == "UNKNOWN") {
      return NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus::UNKNOWN;
    } else if (value == "REQUIRED") {
      return NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus::REQUIRED;
    } else if (value == "NOT_REQUIRED") {
      return NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus::NOT_REQUIRED;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value in NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus value) {
    if (value == NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus::UNKNOWN) {
      return bridging::toJs(rt, "UNKNOWN");
    } else if (value == NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus::REQUIRED) {
      return bridging::toJs(rt, "REQUIRED");
    } else if (value == NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus::NOT_REQUIRED) {
      return bridging::toJs(rt, "NOT_REQUIRED");
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value in NativeConsentModuleAdsConsentPrivacyOptionsRequirementStatus");
    }
  }
};

#pragma mark - NativeConsentModuleAdsConsentStatus

enum class NativeConsentModuleAdsConsentStatus { UNKNOWN, REQUIRED, NOT_REQUIRED, OBTAINED };

template <>
struct Bridging<NativeConsentModuleAdsConsentStatus> {
  static NativeConsentModuleAdsConsentStatus fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == "UNKNOWN") {
      return NativeConsentModuleAdsConsentStatus::UNKNOWN;
    } else if (value == "REQUIRED") {
      return NativeConsentModuleAdsConsentStatus::REQUIRED;
    } else if (value == "NOT_REQUIRED") {
      return NativeConsentModuleAdsConsentStatus::NOT_REQUIRED;
    } else if (value == "OBTAINED") {
      return NativeConsentModuleAdsConsentStatus::OBTAINED;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value in NativeConsentModuleAdsConsentStatus");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeConsentModuleAdsConsentStatus value) {
    if (value == NativeConsentModuleAdsConsentStatus::UNKNOWN) {
      return bridging::toJs(rt, "UNKNOWN");
    } else if (value == NativeConsentModuleAdsConsentStatus::REQUIRED) {
      return bridging::toJs(rt, "REQUIRED");
    } else if (value == NativeConsentModuleAdsConsentStatus::NOT_REQUIRED) {
      return bridging::toJs(rt, "NOT_REQUIRED");
    } else if (value == NativeConsentModuleAdsConsentStatus::OBTAINED) {
      return bridging::toJs(rt, "OBTAINED");
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value in NativeConsentModuleAdsConsentStatus");
    }
  }
};
#pragma mark - NativeConsentModuleAdsConsentInfo

template <typename P0, typename P1, typename P2, typename P3>
struct NativeConsentModuleAdsConsentInfo {
  P0 status;
  P1 canRequestAds;
  P2 privacyOptionsRequirementStatus;
  P3 isConsentFormAvailable;
  bool operator==(const NativeConsentModuleAdsConsentInfo &other) const {
    return status == other.status && canRequestAds == other.canRequestAds && privacyOptionsRequirementStatus == other.privacyOptionsRequirementStatus && isConsentFormAvailable == other.isConsentFormAvailable;
  }
};

template <typename T>
struct NativeConsentModuleAdsConsentInfoBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.status)>(rt, value.getProperty(rt, "status"), jsInvoker),
      bridging::fromJs<decltype(types.canRequestAds)>(rt, value.getProperty(rt, "canRequestAds"), jsInvoker),
      bridging::fromJs<decltype(types.privacyOptionsRequirementStatus)>(rt, value.getProperty(rt, "privacyOptionsRequirementStatus"), jsInvoker),
      bridging::fromJs<decltype(types.isConsentFormAvailable)>(rt, value.getProperty(rt, "isConsentFormAvailable"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String statusToJs(jsi::Runtime &rt, decltype(types.status) value) {
    return bridging::toJs(rt, value);
  }
  static bool canRequestAdsToJs(jsi::Runtime &rt, decltype(types.canRequestAds) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String privacyOptionsRequirementStatusToJs(jsi::Runtime &rt, decltype(types.privacyOptionsRequirementStatus) value) {
    return bridging::toJs(rt, value);
  }
  static bool isConsentFormAvailableToJs(jsi::Runtime &rt, decltype(types.isConsentFormAvailable) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "status", bridging::toJs(rt, value.status, jsInvoker));
    result.setProperty(rt, "canRequestAds", bridging::toJs(rt, value.canRequestAds, jsInvoker));
    result.setProperty(rt, "privacyOptionsRequirementStatus", bridging::toJs(rt, value.privacyOptionsRequirementStatus, jsInvoker));
    result.setProperty(rt, "isConsentFormAvailable", bridging::toJs(rt, value.isConsentFormAvailable, jsInvoker));
    return result;
  }
};



#pragma mark - NativeConsentModuleAdsConsentInfoOptions

template <typename P0, typename P1, typename P2>
struct NativeConsentModuleAdsConsentInfoOptions {
  P0 debugGeography;
  P1 tagForUnderAgeOfConsent;
  P2 testDeviceIdentifiers;
  bool operator==(const NativeConsentModuleAdsConsentInfoOptions &other) const {
    return debugGeography == other.debugGeography && tagForUnderAgeOfConsent == other.tagForUnderAgeOfConsent && testDeviceIdentifiers == other.testDeviceIdentifiers;
  }
};

template <typename T>
struct NativeConsentModuleAdsConsentInfoOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.debugGeography)>(rt, value.getProperty(rt, "debugGeography"), jsInvoker),
      bridging::fromJs<decltype(types.tagForUnderAgeOfConsent)>(rt, value.getProperty(rt, "tagForUnderAgeOfConsent"), jsInvoker),
      bridging::fromJs<decltype(types.testDeviceIdentifiers)>(rt, value.getProperty(rt, "testDeviceIdentifiers"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Value debugGeographyToJs(jsi::Runtime &rt, decltype(types.debugGeography) value) {
    return bridging::toJs(rt, value);
  }
  static bool tagForUnderAgeOfConsentToJs(jsi::Runtime &rt, decltype(types.tagForUnderAgeOfConsent) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array testDeviceIdentifiersToJs(jsi::Runtime &rt, decltype(types.testDeviceIdentifiers) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.debugGeography) {
      result.setProperty(rt, "debugGeography", bridging::toJs(rt, value.debugGeography.value(), jsInvoker));
    }
    if (value.tagForUnderAgeOfConsent) {
      result.setProperty(rt, "tagForUnderAgeOfConsent", bridging::toJs(rt, value.tagForUnderAgeOfConsent.value(), jsInvoker));
    }
    if (value.testDeviceIdentifiers) {
      result.setProperty(rt, "testDeviceIdentifiers", bridging::toJs(rt, value.testDeviceIdentifiers.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeConsentModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "RNGoogleMobileAdsConsentModule";

protected:
  NativeConsentModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeConsentModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["requestInfoUpdate"] = MethodMetadata {.argCount = 1, .invoker = __requestInfoUpdate};
    methodMap_["showForm"] = MethodMetadata {.argCount = 0, .invoker = __showForm};
    methodMap_["showPrivacyOptionsForm"] = MethodMetadata {.argCount = 0, .invoker = __showPrivacyOptionsForm};
    methodMap_["loadAndShowConsentFormIfRequired"] = MethodMetadata {.argCount = 0, .invoker = __loadAndShowConsentFormIfRequired};
    methodMap_["getConsentInfo"] = MethodMetadata {.argCount = 0, .invoker = __getConsentInfo};
    methodMap_["getTCString"] = MethodMetadata {.argCount = 0, .invoker = __getTCString};
    methodMap_["getGdprApplies"] = MethodMetadata {.argCount = 0, .invoker = __getGdprApplies};
    methodMap_["getPurposeConsents"] = MethodMetadata {.argCount = 0, .invoker = __getPurposeConsents};
    methodMap_["getPurposeLegitimateInterests"] = MethodMetadata {.argCount = 0, .invoker = __getPurposeLegitimateInterests};
    methodMap_["reset"] = MethodMetadata {.argCount = 0, .invoker = __reset};
  }
  
private:
  static jsi::Value __requestInfoUpdate(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::requestInfoUpdate) == 2,
      "Expected requestInfoUpdate(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::requestInfoUpdate,  static_cast<NativeConsentModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));
  }

  static jsi::Value __showForm(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::showForm) == 1,
      "Expected showForm(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::showForm,  static_cast<NativeConsentModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __showPrivacyOptionsForm(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::showPrivacyOptionsForm) == 1,
      "Expected showPrivacyOptionsForm(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::showPrivacyOptionsForm,  static_cast<NativeConsentModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __loadAndShowConsentFormIfRequired(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::loadAndShowConsentFormIfRequired) == 1,
      "Expected loadAndShowConsentFormIfRequired(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::loadAndShowConsentFormIfRequired,  static_cast<NativeConsentModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getConsentInfo(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConsentInfo) == 1,
      "Expected getConsentInfo(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getConsentInfo,  static_cast<NativeConsentModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getTCString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getTCString) == 1,
      "Expected getTCString(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getTCString,  static_cast<NativeConsentModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getGdprApplies(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getGdprApplies) == 1,
      "Expected getGdprApplies(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getGdprApplies,  static_cast<NativeConsentModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getPurposeConsents(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getPurposeConsents) == 1,
      "Expected getPurposeConsents(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getPurposeConsents,  static_cast<NativeConsentModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __getPurposeLegitimateInterests(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getPurposeLegitimateInterests) == 1,
      "Expected getPurposeLegitimateInterests(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getPurposeLegitimateInterests,  static_cast<NativeConsentModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __reset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::reset) == 1,
      "Expected reset(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::reset,  static_cast<NativeConsentModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeGoogleMobileAdsModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "RNGoogleMobileAdsModule";

protected:
  NativeGoogleMobileAdsModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeGoogleMobileAdsModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["initialize"] = MethodMetadata {.argCount = 0, .invoker = __initialize};
    methodMap_["setRequestConfiguration"] = MethodMetadata {.argCount = 1, .invoker = __setRequestConfiguration};
    methodMap_["openAdInspector"] = MethodMetadata {.argCount = 0, .invoker = __openAdInspector};
    methodMap_["openDebugMenu"] = MethodMetadata {.argCount = 1, .invoker = __openDebugMenu};
    methodMap_["setAppVolume"] = MethodMetadata {.argCount = 1, .invoker = __setAppVolume};
    methodMap_["setAppMuted"] = MethodMetadata {.argCount = 1, .invoker = __setAppMuted};
  }
  
private:
  static jsi::Value __initialize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::initialize) == 1,
      "Expected initialize(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::initialize,  static_cast<NativeGoogleMobileAdsModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __setRequestConfiguration(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setRequestConfiguration) == 2,
      "Expected setRequestConfiguration(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::setRequestConfiguration,  static_cast<NativeGoogleMobileAdsModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));
  }

  static jsi::Value __openAdInspector(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::openAdInspector) == 1,
      "Expected openAdInspector(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::openAdInspector,  static_cast<NativeGoogleMobileAdsModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __openDebugMenu(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::openDebugMenu) == 2,
      "Expected openDebugMenu(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::openDebugMenu,  static_cast<NativeGoogleMobileAdsModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __setAppVolume(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setAppVolume) == 2,
      "Expected setAppVolume(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setAppVolume,  static_cast<NativeGoogleMobileAdsModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }

  static jsi::Value __setAppMuted(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::setAppMuted) == 2,
      "Expected setAppMuted(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::setAppMuted,  static_cast<NativeGoogleMobileAdsModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());return jsi::Value::undefined();
  }
};


#pragma mark - NativeGoogleMobileAdsNativeModuleNativeAdEventPayload

template <typename P0, typename P1>
struct NativeGoogleMobileAdsNativeModuleNativeAdEventPayload {
  P0 responseId;
  P1 type;
  bool operator==(const NativeGoogleMobileAdsNativeModuleNativeAdEventPayload &other) const {
    return responseId == other.responseId && type == other.type;
  }
};

template <typename T>
struct NativeGoogleMobileAdsNativeModuleNativeAdEventPayloadBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.responseId)>(rt, value.getProperty(rt, "responseId"), jsInvoker),
      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String responseIdToJs(jsi::Runtime &rt, decltype(types.responseId) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "responseId", bridging::toJs(rt, value.responseId, jsInvoker));
    result.setProperty(rt, "type", bridging::toJs(rt, value.type, jsInvoker));
    return result;
  }
};



#pragma mark - NativeGoogleMobileAdsNativeModuleNativeAdImage

template <typename P0, typename P1>
struct NativeGoogleMobileAdsNativeModuleNativeAdImage {
  P0 url;
  P1 scale;
  bool operator==(const NativeGoogleMobileAdsNativeModuleNativeAdImage &other) const {
    return url == other.url && scale == other.scale;
  }
};

template <typename T>
struct NativeGoogleMobileAdsNativeModuleNativeAdImageBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.url)>(rt, value.getProperty(rt, "url"), jsInvoker),
      bridging::fromJs<decltype(types.scale)>(rt, value.getProperty(rt, "scale"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String urlToJs(jsi::Runtime &rt, decltype(types.url) value) {
    return bridging::toJs(rt, value);
  }
  static double scaleToJs(jsi::Runtime &rt, decltype(types.scale) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "url", bridging::toJs(rt, value.url, jsInvoker));
    result.setProperty(rt, "scale", bridging::toJs(rt, value.scale, jsInvoker));
    return result;
  }
};



#pragma mark - NativeGoogleMobileAdsNativeModuleNativeAdProps

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11>
struct NativeGoogleMobileAdsNativeModuleNativeAdProps {
  P0 responseId;
  P1 advertiser;
  P2 body;
  P3 callToAction;
  P4 headline;
  P5 price;
  P6 store;
  P7 starRating;
  P8 icon;
  P9 images;
  P10 mediaContent;
  P11 extras;
  bool operator==(const NativeGoogleMobileAdsNativeModuleNativeAdProps &other) const {
    return responseId == other.responseId && advertiser == other.advertiser && body == other.body && callToAction == other.callToAction && headline == other.headline && price == other.price && store == other.store && starRating == other.starRating && icon == other.icon && images == other.images && mediaContent == other.mediaContent && extras == other.extras;
  }
};

template <typename T>
struct NativeGoogleMobileAdsNativeModuleNativeAdPropsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.responseId)>(rt, value.getProperty(rt, "responseId"), jsInvoker),
      bridging::fromJs<decltype(types.advertiser)>(rt, value.getProperty(rt, "advertiser"), jsInvoker),
      bridging::fromJs<decltype(types.body)>(rt, value.getProperty(rt, "body"), jsInvoker),
      bridging::fromJs<decltype(types.callToAction)>(rt, value.getProperty(rt, "callToAction"), jsInvoker),
      bridging::fromJs<decltype(types.headline)>(rt, value.getProperty(rt, "headline"), jsInvoker),
      bridging::fromJs<decltype(types.price)>(rt, value.getProperty(rt, "price"), jsInvoker),
      bridging::fromJs<decltype(types.store)>(rt, value.getProperty(rt, "store"), jsInvoker),
      bridging::fromJs<decltype(types.starRating)>(rt, value.getProperty(rt, "starRating"), jsInvoker),
      bridging::fromJs<decltype(types.icon)>(rt, value.getProperty(rt, "icon"), jsInvoker),
      bridging::fromJs<decltype(types.images)>(rt, value.getProperty(rt, "images"), jsInvoker),
      bridging::fromJs<decltype(types.mediaContent)>(rt, value.getProperty(rt, "mediaContent"), jsInvoker),
      bridging::fromJs<decltype(types.extras)>(rt, value.getProperty(rt, "extras"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String responseIdToJs(jsi::Runtime &rt, decltype(types.responseId) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> advertiserToJs(jsi::Runtime &rt, decltype(types.advertiser) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String bodyToJs(jsi::Runtime &rt, decltype(types.body) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String callToActionToJs(jsi::Runtime &rt, decltype(types.callToAction) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String headlineToJs(jsi::Runtime &rt, decltype(types.headline) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> priceToJs(jsi::Runtime &rt, decltype(types.price) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> storeToJs(jsi::Runtime &rt, decltype(types.store) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> starRatingToJs(jsi::Runtime &rt, decltype(types.starRating) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::Object> iconToJs(jsi::Runtime &rt, decltype(types.icon) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::Array> imagesToJs(jsi::Runtime &rt, decltype(types.images) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object mediaContentToJs(jsi::Runtime &rt, decltype(types.mediaContent) value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::Object> extrasToJs(jsi::Runtime &rt, decltype(types.extras) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "responseId", bridging::toJs(rt, value.responseId, jsInvoker));
    result.setProperty(rt, "advertiser", bridging::toJs(rt, value.advertiser, jsInvoker));
    result.setProperty(rt, "body", bridging::toJs(rt, value.body, jsInvoker));
    result.setProperty(rt, "callToAction", bridging::toJs(rt, value.callToAction, jsInvoker));
    result.setProperty(rt, "headline", bridging::toJs(rt, value.headline, jsInvoker));
    result.setProperty(rt, "price", bridging::toJs(rt, value.price, jsInvoker));
    result.setProperty(rt, "store", bridging::toJs(rt, value.store, jsInvoker));
    result.setProperty(rt, "starRating", bridging::toJs(rt, value.starRating, jsInvoker));
    result.setProperty(rt, "icon", bridging::toJs(rt, value.icon, jsInvoker));
    result.setProperty(rt, "images", bridging::toJs(rt, value.images, jsInvoker));
    result.setProperty(rt, "mediaContent", bridging::toJs(rt, value.mediaContent, jsInvoker));
    result.setProperty(rt, "extras", bridging::toJs(rt, value.extras, jsInvoker));
    return result;
  }
};



#pragma mark - NativeGoogleMobileAdsNativeModuleNativeMediaContent

template <typename P0, typename P1, typename P2>
struct NativeGoogleMobileAdsNativeModuleNativeMediaContent {
  P0 aspectRatio;
  P1 hasVideoContent;
  P2 duration;
  bool operator==(const NativeGoogleMobileAdsNativeModuleNativeMediaContent &other) const {
    return aspectRatio == other.aspectRatio && hasVideoContent == other.hasVideoContent && duration == other.duration;
  }
};

template <typename T>
struct NativeGoogleMobileAdsNativeModuleNativeMediaContentBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.aspectRatio)>(rt, value.getProperty(rt, "aspectRatio"), jsInvoker),
      bridging::fromJs<decltype(types.hasVideoContent)>(rt, value.getProperty(rt, "hasVideoContent"), jsInvoker),
      bridging::fromJs<decltype(types.duration)>(rt, value.getProperty(rt, "duration"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double aspectRatioToJs(jsi::Runtime &rt, decltype(types.aspectRatio) value) {
    return bridging::toJs(rt, value);
  }
  static bool hasVideoContentToJs(jsi::Runtime &rt, decltype(types.hasVideoContent) value) {
    return bridging::toJs(rt, value);
  }
  static double durationToJs(jsi::Runtime &rt, decltype(types.duration) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "aspectRatio", bridging::toJs(rt, value.aspectRatio, jsInvoker));
    result.setProperty(rt, "hasVideoContent", bridging::toJs(rt, value.hasVideoContent, jsInvoker));
    result.setProperty(rt, "duration", bridging::toJs(rt, value.duration, jsInvoker));
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeGoogleMobileAdsNativeModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "RNGoogleMobileAdsNativeModule";

protected:
  NativeGoogleMobileAdsNativeModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeGoogleMobileAdsNativeModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["load"] = MethodMetadata {.argCount = 2, .invoker = __load};
    methodMap_["destroy"] = MethodMetadata {.argCount = 1, .invoker = __destroy};
    eventEmitterMap_["onAdEvent"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
  }
  
  template <typename OnAdEventType> void emitOnAdEvent(OnAdEventType value) {
    static_assert(bridging::supportsFromJs<OnAdEventType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*eventEmitterMap_["onAdEvent"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }
private:
  static jsi::Value __load(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::load) == 3,
      "Expected load(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::load,  static_cast<NativeGoogleMobileAdsNativeModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));
  }

  static jsi::Value __destroy(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::destroy) == 2,
      "Expected destroy(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::destroy,  static_cast<NativeGoogleMobileAdsNativeModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeInterstitialModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "RNGoogleMobileAdsInterstitialModule";

protected:
  NativeInterstitialModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeInterstitialModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["interstitialLoad"] = MethodMetadata {.argCount = 3, .invoker = __interstitialLoad};
    methodMap_["interstitialShow"] = MethodMetadata {.argCount = 3, .invoker = __interstitialShow};
  }
  
private:
  static jsi::Value __interstitialLoad(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::interstitialLoad) == 4,
      "Expected interstitialLoad(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::interstitialLoad,  static_cast<NativeInterstitialModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __interstitialShow(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::interstitialShow) == 4,
      "Expected interstitialShow(...) to have 4 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::interstitialShow,  static_cast<NativeInterstitialModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asObject(rt)));
  }
};


template <typename T>
class JSI_EXPORT NativeRewardedInterstitialModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "RNGoogleMobileAdsRewardedInterstitialModule";

protected:
  NativeRewardedInterstitialModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeRewardedInterstitialModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["rewardedInterstitialLoad"] = MethodMetadata {.argCount = 3, .invoker = __rewardedInterstitialLoad};
    methodMap_["rewardedInterstitialShow"] = MethodMetadata {.argCount = 3, .invoker = __rewardedInterstitialShow};
  }
  
private:
  static jsi::Value __rewardedInterstitialLoad(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::rewardedInterstitialLoad) == 4,
      "Expected rewardedInterstitialLoad(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::rewardedInterstitialLoad,  static_cast<NativeRewardedInterstitialModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __rewardedInterstitialShow(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::rewardedInterstitialShow) == 4,
      "Expected rewardedInterstitialShow(...) to have 4 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::rewardedInterstitialShow,  static_cast<NativeRewardedInterstitialModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asObject(rt)));
  }
};


template <typename T>
class JSI_EXPORT NativeRewardedModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "RNGoogleMobileAdsRewardedModule";

protected:
  NativeRewardedModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeRewardedModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["rewardedLoad"] = MethodMetadata {.argCount = 3, .invoker = __rewardedLoad};
    methodMap_["rewardedShow"] = MethodMetadata {.argCount = 3, .invoker = __rewardedShow};
  }
  
private:
  static jsi::Value __rewardedLoad(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::rewardedLoad) == 4,
      "Expected rewardedLoad(...) to have 4 parameters");
    bridging::callFromJs<void>(rt, &T::rewardedLoad,  static_cast<NativeRewardedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt));return jsi::Value::undefined();
  }

  static jsi::Value __rewardedShow(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::rewardedShow) == 4,
      "Expected rewardedShow(...) to have 4 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::rewardedShow,  static_cast<NativeRewardedModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asObject(rt)));
  }
};

} // namespace facebook::react
